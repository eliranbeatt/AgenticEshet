"use client";

import { useState, useEffect } from "react";
import { useQuery, useMutation, useAction } from "convex/react";
import { api } from "@/convex/_generated/api";
import { Id } from "@/convex/_generated/dataModel";
import { StructuredQuestion, StructuredAnswer } from "@/convex/lib/zodSchemas";
import { Loader2, CheckCircle2, AlertCircle } from "lucide-react";

interface StructuredQuestionsPanelProps {
    projectId: Id<"projects">;
    stage: "clarification" | "planning" | "solutioning";
}

export function StructuredQuestionsPanel({ projectId, stage }: StructuredQuestionsPanelProps) {
    const session = useQuery(api.structuredQuestions.getActiveSession, { projectId, stage });
    const startSession = useMutation(api.structuredQuestions.startSession);
    const runAgent = useAction(api.agents.structuredQuestions.run);
    
    const [isStarting, setIsStarting] = useState(false);

    const handleStart = async () => {
        setIsStarting(true);
        try {
            const sessionId = await startSession({ projectId, stage });
            await runAgent({ projectId, stage, sessionId, runId: undefined as any }); // runId will be generated by action wrapper if needed, but here we might need to pass a new ID or let the action handle it. 
            // Wait, the action expects runId. We should probably generate it or let the backend handle it.
            // The user request said: "agents.structuredQuestions.run({projectId, stage, sessionId})"
            // But my implementation requires runId. I should probably generate a runId here or make it optional in the action.
            // Let's fix the action to make runId optional or generate it.
            // Actually, usually we create a runId via mutation before calling action to track it.
            // For now, let's assume we need to create a runId.
        } catch (e) {
            console.error(e);
        } finally {
            setIsStarting(false);
        }
    };

    if (session === undefined) return <div>Loading session...</div>;

    if (!session) {
        return (
            <div className="flex flex-col items-center justify-center h-full p-8 text-center space-y-4">
                <h3 className="text-lg font-medium">Structured Questions</h3>
                <p className="text-gray-500 max-w-md">
                    Start a structured Q&A session to clarify requirements before generating ideas.
                </p>
                <button
                    onClick={handleStart}
                    disabled={isStarting}
                    className="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700 disabled:opacity-50 flex items-center gap-2"
                >
                    {isStarting ? <Loader2 className="w-4 h-4 animate-spin" /> : null}
                    Start Session
                </button>
            </div>
        );
    }

    return <ActiveSessionView session={session} projectId={projectId} stage={stage} />;
}

function ActiveSessionView({ session, projectId, stage }: { session: any, projectId: Id<"projects">, stage: any }) {
    const latestTurn = useQuery(api.structuredQuestions.getLatestTurn, { sessionId: session._id });
    const saveAnswers = useMutation(api.structuredQuestions.saveAnswers);
    const runAgent = useAction(api.agents.structuredQuestions.run);

    const [answers, setAnswers] = useState<Record<string, StructuredAnswer>>({});
    const [isSubmitting, setIsSubmitting] = useState(false);

    // Reset answers when turn changes
    useEffect(() => {
        setAnswers({});
    }, [latestTurn?.turnNumber]);

    if (latestTurn === undefined) return <div>Loading turn...</div>;
    if (!latestTurn) return <div>No turns found. Waiting for agent...</div>;

    // Check if turn is already answered
    const isTurnDone = latestTurn.answers && latestTurn.answers.length > 0;

    const questions = latestTurn.questions as StructuredQuestion[];

    const handleAnswerChange = (qId: string, field: keyof StructuredAnswer, value: any) => {
        setAnswers(prev => ({
            ...prev,
            [qId]: {
                ...prev[qId],
                questionId: qId,
                [field]: value
            }
        }));
    };

    const handleSubmit = async () => {
        setIsSubmitting(true);
        try {
            const answerList = Object.values(answers);
            await saveAnswers({
                sessionId: session._id,
                turnNumber: latestTurn.turnNumber,
                answers: answerList,
            });

            await runAgent({
                projectId,
                stage,
                sessionId: session._id,
            });
        } catch (e) {
            console.error(e);
            alert("Failed to submit answers");
        } finally {
            setIsSubmitting(false);
        }
    };

    const allAnswered = questions.every(q => {
        const ans = answers[q.id];
        if (!ans) return false;
        if (!ans.quick) return false;
        if (q.expectsFreeText && !ans.text) return false;
        return true;
    });

    if (isTurnDone) {
        return (
            <div className="flex flex-col items-center justify-center h-full space-y-4">
                <Loader2 className="w-8 h-8 animate-spin text-blue-600" />
                <p>Generating next questions...</p>
            </div>
        );
    }

    return (
        <div className="flex flex-col h-full">
            <div className="p-4 border-b bg-gray-50 flex justify-between items-center">
                <div className="text-sm font-medium text-gray-700">
                    Turn {latestTurn.turnNumber} â€¢ {questions.length} Questions
                </div>
                {/* Optional: Reset button */}
            </div>

            <div className="flex-1 overflow-y-auto p-4 space-y-6">
                {questions.map(q => (
                    <QuestionCard
                        key={q.id}
                        question={q}
                        answer={answers[q.id]}
                        onChange={(field, val) => handleAnswerChange(q.id, field, val)}
                    />
                ))}
            </div>

            <div className="p-4 border-t bg-white">
                <button
                    onClick={handleSubmit}
                    disabled={!allAnswered || isSubmitting}
                    className="w-full py-2 bg-blue-600 text-white rounded font-medium hover:bg-blue-700 disabled:opacity-50 disabled:cursor-not-allowed flex justify-center items-center gap-2"
                >
                    {isSubmitting ? <Loader2 className="w-4 h-4 animate-spin" /> : null}
                    Submit Answers
                </button>
            </div>
        </div>
    );
}

function QuestionCard({
    question,
    answer,
    onChange
}: {
    question: StructuredQuestion;
    answer?: StructuredAnswer;
    onChange: (field: keyof StructuredAnswer, value: any) => void;
}) {
    return (
        <div className="border rounded-lg p-4 bg-white shadow-sm space-y-3">
            <div className="flex justify-between items-start gap-2">
                <h4 className="font-medium text-gray-900">{question.title}</h4>
                {question.blocking && (
                    <span className="text-xs bg-red-100 text-red-700 px-2 py-0.5 rounded">Required</span>
                )}
            </div>
            
            {question.prompt && (
                <p className="text-sm text-gray-500">{question.prompt}</p>
            )}

            <div className="space-y-3 pt-2">
                <div className="flex flex-wrap gap-2">
                    {(["yes", "no", "idk", "irrelevant"] as const).map(opt => (
                        <button
                            key={opt}
                            onClick={() => onChange("quick", opt)}
                            className={`px-3 py-1.5 text-sm rounded border transition-colors ${
                                answer?.quick === opt
                                    ? "bg-blue-100 border-blue-300 text-blue-800 font-medium"
                                    : "bg-white border-gray-200 text-gray-600 hover:bg-gray-50"
                            }`}
                        >
                            {opt === "idk" ? "I don't know" : opt.charAt(0).toUpperCase() + opt.slice(1)}
                        </button>
                    ))}
                </div>

                {(question.expectsFreeText || answer?.quick) && (
                    <textarea
                        value={answer?.text || ""}
                        onChange={(e) => onChange("text", e.target.value)}
                        placeholder={question.expectsFreeText ? "Please provide details..." : "Optional details..."}
                        className="w-full text-sm border rounded p-2 focus:ring-2 focus:ring-blue-500 focus:border-transparent outline-none"
                        rows={2}
                    />
                )}
            </div>
        </div>
    );
}
