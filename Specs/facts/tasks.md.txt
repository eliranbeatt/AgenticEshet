tasks.md
# Tasks — Full Phase-by-Phase Implementation Plan (Requirements → Design → Build → Backfill → Harden)

This is an end-to-end plan that assumes your current stack and existing modules (agents/flow, flowWorkspaces, agentRuns, structuredQuestionSessions, projectItems, canonicalItems, priceObservations). :contentReference[oaicite:4]{index=4}

---

## Phase 0 — Prepare the ground (0.5–1 day)
### 0.1 Add feature flag
- Add `facts_pipeline_enabled` at project level (or settings key).
- Default OFF.

### 0.2 Add “debug surfaces” early
- Add minimal UI placeholders:
  - “Facts” panel (empty state)
  - “Current State” panel (empty state)
  - “Parse status” badge

**Exit criteria**
- You can enable/disable per project without breaking existing flows.

---

## Phase 1 — Schema + registries (1–2 days)
### 1.1 Add new tables and indexes
Implement in `convex/schema.ts`:
- `turnBundles`
- `factParseRuns`
- `facts`
- `knowledgeBlocks`
- (optional) `factConflicts`

Add indexes:
- `turnBundles.by_project_createdAt`
- `factParseRuns.by_bundle`
- `facts.by_scope_key`, `facts.by_project_status`, `facts.by_item`
- `knowledgeBlocks.by_scope_block`

### 1.2 Add Fact key registry
Create `convex/lib/facts/registry.ts`:
- `FACT_KEY_REGISTRY`: key → { valueType, stageAllowlist, blockKey, risk }
- `HIGH_RISK_KEYS`
- `BLOCK_KEY_ENUM`

### 1.3 Add Zod schemas
Create `convex/lib/facts/schemas.ts`:
- FactOp schema
- Fact value schema by type
- Evidence schema

**Exit criteria**
- Convex deploy works; types compile; no runtime usage yet.

---

## Phase 2 — TurnBundle creation (1–3 days)
### 2.1 Identify turn “commit points”
You have:
- Structured Q submit
- Generation completion
Also include:
- Free chat submit (when sent outside structured Q)

### 2.2 Implement `turnBundles.createFromTurn` (Convex mutation or action)
Inputs:
- projectId
- stage
- scope + itemIds (if any)
- structured questions + ids (optional)
- answers + ids (optional)
- free chat (optional)
- agent output text (optional)
- itemRefs (id+name list for scope or full project)

Output:
- turnBundleId

### 2.3 Make bundle format deterministic
- Always include all headers.
- For missing sections use `(none)`.
- Store immutable bundleText.

### 2.4 Wire the UI to create bundles
- On submit/completion: call createFromTurn.
- Store returned turnBundleId on the “turn record” (structuredQuestionTurns or chat message group).

**Exit criteria**
- Every turn produces one TurnBundle row with stable formatting.

---

## Phase 3 — One-call-per-turn parser (2–5 days)
### 3.1 Implement `facts.parseTurnBundle(turnBundleId)` (Convex action)
Steps:
1) Check feature flag enabled.
2) Check idempotency:
   - if existing succeeded run for bundle → return.
3) Create `factParseRuns` row status=running.
4) Load TurnBundle text.
5) Build CurrentFactSnapshot:
   - list items (id+name) in scope
   - accepted facts for keys relevant to stage
   - high-risk keys list
6) Call GPT-5-mini using existing schema call helper (`callChatWithSchema` pattern).
7) Store raw FactOps (optional) for debugging.
8) Mark run succeeded/failed.

### 3.2 Create parser prompt templates
- System prompt: strict extraction only + evidence offsets.
- User prompt: includes snapshot + TurnBundle.

### 3.3 Enforce “agent output = proposed”
- Parser sets needsReview=true for any AGENT_OUTPUT facts.
- Backend also enforces this even if model forgets.

**Exit criteria**
- For any turn, you can run parse and get a list of FactOps.

---

## Phase 4 — Verification + reconciliation (2–6 days)
### 4.1 Implement evidence verification
Create `convex/lib/facts/verify.ts`:
- validate offsets
- validate quote match
- enforce quote length limit
- enforce allowed source sections

### 4.2 Implement reconciliation
Create `convex/lib/facts/reconcile.ts`:
- `applyFactOps(projectId, parseRunId, ops[])`
- deterministic insert rules:
  - accept / propose / conflict / note
- store facts in `facts` table
- compute stats and update `factParseRuns.stats`

### 4.3 Implement conflict detection
- If accepted exists and new differs:
  - conflict when high-risk or low-confidence
  - else accept/supersede depending on policy

### 4.4 Add mutations for user actions
- `facts.accept(factId)`
- `facts.reject(factId)`
- `facts.resolveConflict(scope,key,chosenFactId)`

**Exit criteria**
- Facts are stored, visible, and safe (no silent overwrites).

---

## Phase 5 — Facts UI (2–6 days)
### 5.1 Build “Facts” panel
Sections:
- Accepted (recent)
- Proposed / Needs review
- Conflicts
- Notes

### 5.2 Evidence highlight viewer
- show TurnBundle snippet
- highlight quote by offsets
- show “turn metadata” (stage/scope)

### 5.3 Quick actions
- Accept / Reject
- Resolve conflict (choose active)

**Exit criteria**
- User can review and control truth without editing raw text.

---

## Phase 6 — KnowledgeBlocks (Smart Updater) (3–8 days)
### 6.1 Create initial blocks for project and items
When pipeline enabled:
- Create default project blocks
- Create default item blocks

### 6.2 Implement patch engine
Create `convex/lib/knowledgeBlocks/patch.ts`:
- map fact keys → blockKey
- apply minimal patch to block.json
- regenerate renderedMarkdown deterministically
- increment revision

### 6.3 Wire patch application
After reconcile:
- compute affected blocks from inserted/updated facts
- patch blocks (project + item blocks)

### 6.4 Add “Current State” UI
- Display blocks relevant to stage:
  - ideation: summary + constraints + openQuestions
  - planning: logistics + timeline + budget (with review flags)
  - solutioning: materials + production + decisions

**Exit criteria**
- Current state updates without rewriting whole text.

---

## Phase 7 — Item materialization (3–10 days)
### 7.1 Choose projection approach
Start with compute-on-read (simpler), then add cache if needed.

### 7.2 Implement item projection
Create `convex/itemsProjection.ts`:
- `getItemProjection(itemId)`:
  - load manualOverrides
  - load accepted facts for item
  - compute structured projection fields

### 7.3 Hook into item UI
- Show projection fields with “source” (fact evidence).
- Add manual edit controls that write manualOverrides.

### 7.4 Optional: manual edit produces a fact
If you want everything in the ledger:
- create a “manual fact” with special evidence type (no offsets).

**Exit criteria**
- Items show faithful structured data driven by accepted facts + overrides.

---

## Phase 8 — Canonical items linking (2–8 days)
### 8.1 Add canonical linking UI to materials/lines
- Search canonicalItems
- Show suggestions via normalization map
- Save canonicalItemId on the line/ref

### 8.2 Integrate price memory panel
- Show recent priceObservations for canonicalItemId
- Vendor suggestions
- Allow “apply suggested price” to planning lines (still reviewable)

### 8.3 Store as decision
- Write a decision entry in knowledgeBlocks:
  - “Material X linked to canonical item Y”

**Exit criteria**
- Canonical links exist and drive price memory.

---

## Phase 9 — Cross-scope consistency (2–7 days)
### 9.1 Add @item mention picker in free chat
- Inserts stable token
- Stores resolved itemIds in message metadata

### 9.2 Ensure every turn has scope metadata
- Structured Q turns already have stage; add scope itemIds.
- Free chat/generation turns include itemIds when selected/mentioned.

### 9.3 Bundle includes itemRefs + selectedItemIds
- Parser can accurately scope facts to item.

**Exit criteria**
- Project-level item changes reflect in item blocks and item projection immediately.

---

## Phase 10 — Backfill existing projects (2–10 days)
### 10.1 Create backfill bundler
- Build synthetic TurnBundles from historical:
  - structuredQuestionTurns
  - key chat messages
- Batch by:
  - day, thread, or “N messages”
- Mark all resulting facts as proposed first (safe rollout).

### 10.2 Add admin backfill screen
- Select project
- Run backfill
- Show progress + errors
- Show review queue afterwards

**Exit criteria**
- Existing projects can adopt pipeline without manual re-entry.

---

## Phase 11 — Hardening: tests, monitoring, performance (ongoing)
### 11.1 Unit tests
- evidence verifier
- reconciliation rules
- patch engine determinism

### 11.2 Integration tests
- structured Q → parse once → facts → blocks → item projection
- free chat item edit → scoped fact → item projection updates
- conflict creation + resolution

### 11.3 Monitoring
- Track parse success/fail rate per project
- Track average parse latency
- Alert on repeated failures

### 11.4 Performance optimizations
- Snapshot trimming (only stage-relevant keys)
- Projection caching if read load is heavy
- Avoid re-rendering all blocks; only patch impacted ones

**Exit criteria**
- Stable, observable, and fast enough for daily use.

---

## Implementation note (important)
Keep the “reasoning updater” separate from truth:
- The parser extracts evidence-anchored facts (truth).
- Any “enricher” agent produces:
  - proposed notes, open questions, checklists,
  - but never rewrites truth blocks.